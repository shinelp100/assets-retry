{"version":3,"file":"assets-retry.umd.js","sources":["../src/polyfill.ts","../src/util.ts","../src/url.ts","../src/constants.ts","../src/retry-async.ts","../src/collector.ts","../src/retry-sync.ts","../src/retry-css.ts","../src/assets-retry.ts"],"sourcesContent":["/**\n * polyfill for Object.assign\n */\nexport default !(function ObjectAssign(): any{\n    if (typeof Object.assign !== 'function') {\n        // Must be writable: true, enumerable: false, configurable: true\n        Object.defineProperty(Object, \"assign\", {\n          value: function assign(target: any) { // .length of function is 2\n            'use strict';\n            if (target === null || target === undefined) {\n              throw new TypeError('Cannot convert undefined or null to object');\n            }\n            var to = Object(target);\n            for (var index = 1; index < arguments.length; index++) {\n              var nextSource = arguments[index];\n              if (nextSource !== null && nextSource !== undefined) {\n                for (var nextKey in nextSource) {\n                  // Avoid bugs when hasOwnProperty is shadowed\n                  if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n                    to[nextKey] = nextSource[nextKey];\n                  }\n                }\n              }\n            }\n            return to;\n          },\n          writable: true,\n          configurable: true\n        });\n    }\n})();","import {\n    scriptTag,\n    linkTag,\n    doc,\n    retryIdentifier,\n    ScriptElementCtor,\n    LinkElementCtor,\n    ImageElementCtor,\n    ElementCtor\n} from './constants'\n\nexport const identity = function<T>(x: T): T {\n    return x\n}\nexport const noop = () => {\n    /* noop */\n}\n\nexport const hasOwn = Object.prototype.hasOwnProperty\n/**\n * safely calls a function\n *\n * @template T this\n * @template R ReturnType<func>\n * @param {(this: T, ...callbackArgs: any[]) => R} func\n * @param {T} thisArg\n * @param {*} args\n * @returns {R}\n */\nexport const safeCall = function<T, R>(\n    func: (this: T, ...callbackArgs: any[]) => R,\n    thisArg: T,\n    args: any\n): R {\n    // eslint-disable-next-line\n    if (typeof func !== 'function') {\n        return null as any\n    }\n    return func.call(thisArg, args)\n}\n\n/**\n * replace a substring with new one\n *\n * @param {string} current current string\n * @param {string} oldStr substring to replace\n * @param {string} newStr new string\n * @returns\n */\nexport const stringReplace = function(current: string, oldStr: string, newStr: string) {\n    const idx = current.indexOf(oldStr)\n    if (idx === -1) {\n        return current\n    }\n    return current.substring(0, idx) + newStr + current.substring(idx + oldStr.length)\n}\n\n/**\n * remove duplicates from an array of strings\n */\n// 过滤掉所有相同属性\nexport const unique = function(array: string[]) {\n    const map = {} as any\n    array.forEach(item => {\n        map[item] = true\n    })\n    return Object.keys(map)\n}\n\n/**\n * convert a camelCase string to a dash-separated string.\n *\n * @param {string} str\n * @returns\n */\nexport const toSlug = function(str: string) {\n    return str.replace(/([a-z])([A-Z])/g, (_, $1, $2) => `${$1}-${$2.toLowerCase()}`)\n}\n\n/**\n * transform an array-like object to array\n *\n * @template T\n * @param {ArrayLike<T>} arrayLike\n * @returns {T[]}\n */\nexport const arrayFrom = function<T>(arrayLike: Iterable<T> | ArrayLike<T>): T[] {\n    return [].slice.call(arrayLike)\n}\n/**\n * collect all property names from current object to its ancestor\n *\n * @param {any} obj\n * @returns\n */\n// 获取script、link标签中除constructor的所有属性\nexport const collectPropertyNames = function(obj: any) {\n    const getProto = Object.getPrototypeOf\n        ? Object.getPrototypeOf\n        : function(x: any) {\n              return x.__proto__\n          }\n    let keys = Object.keys(obj)\n    while (getProto(obj)) {\n        keys = keys.concat(Object.keys(getProto(obj)))\n        obj = getProto(obj)\n    }\n    return keys.filter(key => key !== 'constructor')\n}\n\n/**\n * @example\n * isFunctionProperty(HTMLScriptElement.prototype, 'src); // false\n * isFunctionProperty(HTMLScriptElement.prototype, 'getAttribute'); // true\n * @param {any} proto\n * @param {string} key\n * @returns\n */\nexport const isFunctionProperty = function(proto: any, key: string) {\n    try {\n        return typeof proto[key] === 'function'\n    } catch (e) {\n        // TypeError: Illegal invocation\n        // when evaluating properties like\n        // HTMLScriptElement.prototype.src\n        return false\n    }\n}\n\n/**\n * on some browsers, calling `document.write` when\n * `document.readyState` is `loading` will clear the whole\n * page, which is not what we wanted.\n *\n * @returns\n */\nexport const supportDocumentWrite = () => {\n    return !/Edge|MSIE|rv:/i.test(navigator.userAgent)\n}\n\n/**\n * loads a new script element by previous failed script element\n *\n * @param {HTMLScriptElement} $script previous script element\n * @param {string} newSrc new url to try\n */\nexport const loadNextScript = function(\n    $script: HTMLScriptElement,\n    newSrc: string,\n    onload: () => void = noop,\n    isAsync = false\n) {\n    // when dealing with failed script tags in html,\n    // use `document.write` to ensure the correctness\n    // of loading order\n    // 重要：是否是同步加载脚本，只有当script被同步加载时页面的加载才会被阻塞，这时候doc.readyState === 'loading'，我们通过doc.write阻塞页面同步插入脚本，达到保证script加载和执行的顺序\n    const isAsyncScript = isAsync || $script.defer || $script.async\n    // only use document.write for non-async scripts,\n    // which includes script tag created by document.createElement\n    // or with `defer` or `async` attribute\n    if (doc.readyState === 'loading' && supportDocumentWrite() && !isAsyncScript) {\n        // `\\x3Cscript data-retry-id=\"62s5e9uku6\" src=\"http://i1.hdfimg.com/ssi/js/jweixin-1.6.0true.js\" onerror=\"console.log('shinelp100')\">\\x3C/script>`\n        const retryId = randomString()\n        const newHtml = $script.outerHTML\n            // delete previous retry id\n            .replace(/data-retry-id=\"[^\"]+\"/, '')\n            .replace(/src=(?:\"[^\"]+\"|.+)([ >])/, `${retryIdentifier}=${retryId} src=\"${newSrc}\"$1`)\n        doc.write(newHtml)\n        // 增加对loadNextScript方法onload的扩展性\n        const newScript = doc.querySelector(\n            `script[${retryIdentifier}=\"${retryId}\"]`\n        ) as HTMLScriptElement\n        if (newScript) {\n            newScript.onload = onload\n        }\n        return\n    }\n    // script中添加async、defer异步会不阻塞dom的加载（document.readyState: loading ----> interactive ----> complete）\n    const $newScript = doc.createElement(scriptTag)\n    // copy script properties except src:\n    // type, noModule, charset, async, defer,\n    // crossOrigin, text, referrerPolicy, event,\n    // htmlFor, integrity (chrome)\n    Object.keys(ScriptElementCtor.prototype).forEach(function(key: string) {\n        if (key !== 'src' && ($script as any)[key] && typeof ($script as any)[key] !== 'object') {\n            try {\n                ;($newScript as any)[key] = ($script as any)[key]\n            } catch (_) {\n                /* noop */\n            }\n        }\n    })\n    $newScript.src = newSrc\n    $newScript.onload = $script.onload\n    $newScript.onerror = $script.onerror\n    $newScript.setAttribute(retryIdentifier, randomString())\n    // webpack nonce for csp\n    const originalNonce = $script.getAttribute('nonce')\n    if (originalNonce) {\n        $newScript.setAttribute('nonce', originalNonce)\n    }\n    doc.getElementsByTagName('head')[0].appendChild($newScript)\n}\n\n/**\n * get rules from styleSheet\n *\n * @param {CSSStyleSheet} styleSheet\n * @returns\n */\nexport const getCssRules = function(styleSheet: CSSStyleSheet) {\n    try {\n        return styleSheet.rules\n    } catch (_) {\n        try {\n            return styleSheet.cssRules\n        } catch (_) {\n            return null\n        }\n    }\n}\n/**\n * test if current browser support CSSRuleList\n *\n * @param {CSSStyleSheet} styleSheet\n * @returns\n */\nexport const supportRules = function(styleSheet: CSSStyleSheet) {\n    const rules = getCssRules(styleSheet)\n    return !!rules\n}\n\n/**\n * loads a new link element by previous failed link element\n *\n * @param {HTMLLinkElement} $link previous link element\n * @param {string} newHref new url to try\n */\nexport const loadNextLink = function($link: HTMLLinkElement, newHref: string, onload?: () => void) {\n    const $newLink = doc.createElement(linkTag)\n    // copy link properties except href:\n    // disabled, href, crossOrigin, rel, relList, media, hreflang,\n    // type, as, referrerPolicy, sizes, imageSrcset, imageSizes,\n    // charset, rev, target, sheet, integrity, import (chrome)\n    Object.keys(LinkElementCtor.prototype).forEach(function(key: string) {\n        if (key !== 'href' && ($link as any)[key] && typeof ($link as any)[key] !== 'object') {\n            try {\n                ;($newLink as any)[key] = ($link as any)[key]\n            } catch (_) {\n                /* noop */\n            }\n        }\n    })\n    $newLink.href = newHref\n    $newLink.onload = onload || $link.onload\n    $newLink.onerror = $link.onerror\n    $newLink.setAttribute(retryIdentifier, randomString())\n    doc.getElementsByTagName('head')[0].appendChild($newLink)\n}\n\nexport const hashTarget = function(element: EventTarget | null) {\n    if (!element) {\n        return 'null'\n    }\n    if (!(element instanceof ElementCtor)) {\n        return 'not_supported'\n    }\n    const nodeName = element.nodeName\n    const src = (element as any).src\n    const href = (element as any).href\n    const dataRetryId = element.getAttribute(retryIdentifier)\n    return [nodeName, src, href, dataRetryId].join(';')\n}\n\nexport const randomString = () =>\n    Math.random()\n        .toString(36)\n        .slice(2)\n\n/**\n * 获取 HTML 标签中包含的 URL 信息\n * @param target\n */\nexport const getTargetUrl = function(target: EventTarget | null) {\n    if (target instanceof ScriptElementCtor || target instanceof ImageElementCtor) {\n        return target.src\n    }\n    if (target instanceof LinkElementCtor) {\n        return target.href\n    }\n    return ''\n}\n","import { retryCollector, RetryStatistics } from './collector'\nimport { retryTimesProp, failedProp, succeededProp } from './constants'\n\nexport type Domain = string[] | { [x: string]: string }\nexport interface DomainMap {\n    [x: string]: string\n}\n\n/**\n * generate the domain map from user\n * @example\n * generateDomainMap(['a.cdn', 'b.cdn', 'c.cdn']) // {'a.cdn': 'b.cdn', 'b.cdn': 'c.cdn', 'c.cdn': 'a.cdn'}\n *\n * @param {Domain} domains\n * @returns {DomainMap}\n */\nexport const prepareDomainMap = function(domains: Domain): DomainMap {\n    // array\n    if (Array.isArray(domains)) {\n        return domains.reduce(function(domainMap, domain, idx, array) {\n            domainMap[domain] = array[(idx + 1) % array.length]\n            return domainMap\n        }, {} as DomainMap)\n    }\n    // object\n    // generateDomainMap(['a.cdn', 'b.cdn', 'c.cdn']) // {'a.cdn': 'b.cdn', 'b.cdn': 'c.cdn', 'c.cdn': 'a.cdn'}\n    return domains\n}\n\nexport const prepareDomainMaps = function(domains: Domain): DomainMap {\n    // array\n    if (Array.isArray(domains)) {\n        if(domains.some(item => !Array.isArray(item))){\n            return prepareDomainMap(domains)\n        }\n        const domainsUnion = {};\n        for(let i = 0; i < domains.length; i++){\n            Object.assign(domainsUnion, prepareDomainMap(<any>domains[i]))\n        }\n        return domainsUnion;\n    }\n    // object\n    // generateDomainMap(['a.cdn', 'b.cdn', 'c.cdn']) // {'a.cdn': 'b.cdn', 'b.cdn': 'c.cdn', 'c.cdn': 'a.cdn'}\n    return domains\n}\n\n/**\n * get path from src\n * @example\n * getUrlPath('https://a.cdn/js/1.js', 'a.cdn'); // '/js/1.js'\n * getUrlPath('https://a.cdn/namespace/js/1.js', 'a.cdn/namespace'); // '/js/1.js'\n * @param {string} src script src\n * @param {string} currentDomain domain name\n * @returns {string}\n */\nexport const getUrlPath = function(src: string, currentDomain: string) {\n    return src.substr(src.indexOf(currentDomain) + currentDomain.length, src.length)\n}\n\n/**\n * find out the domain of current loading script\n *\n * @param {string} src\n * @param {{ [x: string]: string }} domainMap\n * @returns\n */\nexport const getCurrentDomain = function(src: string, domainMap: DomainMap) {\n    return (\n        Object.keys(domainMap)\n            .filter(function(domain) {\n                return src.indexOf(domain) > -1\n            })\n            // sort by length (relevance)\n            .sort((prev, next) => next.length - prev.length)[0]\n    )\n}\n\n/**\n * extract domain from url, and get the\n * corresponding statistic collector\n * @param {string} url\n * @returns\n */\nexport const extractInfoFromUrl = function(\n    url: string,\n    domainMap: DomainMap\n): [string?, RetryStatistics?] {\n    const [srcPath, currentDomain] = splitUrl(url, domainMap)\n    if (!srcPath) {\n        return []\n    }\n    retryCollector[srcPath] = retryCollector[srcPath] || {\n        [retryTimesProp]: 0,\n        [failedProp]: [],\n        [succeededProp]: []\n    }\n    return [currentDomain, retryCollector[srcPath]]\n}\n\nexport const splitUrl = function(url: string, domainMap: DomainMap): [string, string] {\n    const currentDomain = getCurrentDomain(url, domainMap)\n    if (!currentDomain) {\n        return ['', '']\n    }\n    const srcPath = getUrlPath(url, currentDomain)\n    return [srcPath, currentDomain]\n}\n","export const retryTimesProp = 'retryTimes'\nexport const succeededProp = 'succeeded'\nexport const failedProp = 'failed'\nexport const maxRetryCountProp = 'maxRetryCount'\nexport const onRetryProp = 'onRetry'\nexport const onSuccessProp = 'onSuccess'\nexport const onFailProp = 'onFail'\nexport const domainProp = 'domain'\nexport const innerProxyProp = '_assetsRetryProxy'\nexport const innerOnloadProp = '_assetsRetryOnload'\nexport const innerOnerrorProp = '_assetsRetryOnerror'\nexport const scriptTag = 'script'\nexport const linkTag = 'link'\nexport const hookedIdentifier = 'data-assets-retry-hooked'\nexport const ignoreIdentifier = 'data-assets-retry-ignore'\nexport const retryIdentifier = 'data-retry-id'\nexport const win = window\nexport const doc = window.document\nexport const ElementCtor = win.HTMLElement\nexport const ScriptElementCtor = win.HTMLScriptElement\nexport const StyleElementCtor = win.HTMLStyleElement\nexport const LinkElementCtor = win.HTMLLinkElement\nexport const ImageElementCtor = win.HTMLImageElement\n","import {\n    collectPropertyNames,\n    stringReplace,\n    isFunctionProperty,\n    loadNextScript,\n    safeCall,\n    hasOwn,\n    noop,\n    getTargetUrl,\n    loadNextLink,\n    unique\n} from './util'\n\nimport {\n    retryTimesProp,\n    maxRetryCountProp,\n    onRetryProp,\n    domainProp,\n    innerProxyProp,\n    innerOnloadProp,\n    innerOnerrorProp,\n    linkTag,\n    scriptTag,\n    hookedIdentifier,\n    ignoreIdentifier,\n    doc,\n    ScriptElementCtor,\n    LinkElementCtor\n} from './constants'\nimport { retryCollector } from './collector'\nimport { prepareDomainMaps, extractInfoFromUrl } from './url'\nimport { InnerAssetsRetryOptions } from './assets-retry'\n\ntype DynamicElement = HTMLScriptElement | HTMLLinkElement\n\nexport interface HookedElement {\n    [innerProxyProp]: DynamicElement\n    [innerOnerrorProp]: (e: Partial<Event>) => void\n    [x: string]: any\n}\n\n// cache all properties of HTMLScriptElement.prototype\n// (including prototype properties) because it's big (length > 200)\n// otherwise it would be calculated every time when\n// a script request failed.\nlet scriptAndLinkProperties: string[]\ntry {\n    // 获取script&link标签中所有的属性，合并后的属性\n    scriptAndLinkProperties = unique([\n        ...collectPropertyNames(ScriptElementCtor.prototype),\n        ...collectPropertyNames(LinkElementCtor.prototype)\n    ])\n} catch (_) {\n    /* noop */\n}\n\n/**\n * create the descriptor of hooked element object,\n * accessing any property on the hooked element object\n * will be delegated to the real HTMLElement\n * except onload/onerror events\n *\n * @param {any} self hookedScript\n * @param {object} opts\n * @returns\n */\nconst getHookedElementDescriptors = function(self: HookedElement, opts: InnerAssetsRetryOptions) {\n    // 最大重试次数\n    const maxRetryCount = opts[maxRetryCountProp]\n    // prepareDomainMap(['a.cdn', 'b.cdn', 'c.cdn']) ---> {'a.cdn': 'b.cdn', 'b.cdn': 'c.cdn', 'c.cdn': 'a.cdn'}\n    const domainMap = prepareDomainMaps(opts[domainProp])\n    // 通过该参数可自定义 URL 的转换方式\n    const onRetry = opts[onRetryProp]\n    // scriptAndLinkProperties script&link标签中所有的属性，合并后的属性\n    return scriptAndLinkProperties.reduce(function(descriptor, key) {\n        // 判断是否是function\n        const isFn = isFunctionProperty(ScriptElementCtor.prototype, key)\n        // for function properties,\n        // do not assign getters/setters\n        if (isFn) {\n            descriptor[key] = {\n                value: function() {\n                    // 如果是一个function 就用window.HTMLScriptElement call一下\n                    return (self[innerProxyProp] as any)[key].apply(self[innerProxyProp], arguments)\n                }\n            }\n        } else {\n            descriptor[key] = {\n                set: function(newVal) {\n                    // 真实未被代理的Element（script、link对象）\n                    const realElement = self[innerProxyProp]\n                    // 代理onerror事件\n                    if (key === 'onerror') {\n                        self[innerOnerrorProp] = newVal\n                        // hook error events,\n                        // forward the original onerror handler\n                        // to the next script element to load\n                        realElement.onerror = function(event: Event | string) {\n                            // script、link的event 错误对象是如下：\n                            // var target = e.target || e.srcElement;\n                            // var isElementTarget = target instanceof HTMLScriptElement || target instanceof HTMLLinkElement || target instanceof HTMLImageElement;\n                            if (typeof event === 'string') return\n                            event.stopPropagation && event.stopPropagation()\n                            const callOriginalOnError = () =>\n                                safeCall(self[innerOnerrorProp], realElement, event)\n                            // 获取script的src、link的href\n                            const url = getTargetUrl(realElement)\n                            // 获取当前请求的domain、和收集器（retryTimes次数，failed失败请求url数组、succeeded成功请求url数组）\n                            const [currentDomain, currentCollector] = extractInfoFromUrl(\n                                url,\n                                domainMap\n                            )\n                            // 此标签是否 data-assets-retry-ignore 忽略重试\n                            const shouldIgnore = realElement.hasAttribute(ignoreIdentifier)\n                            // 没有currentDomain或currentCollector收集器或是忽略标签 直接调用原onerror\n                            if (!currentDomain || !currentCollector || shouldIgnore) {\n                                return callOriginalOnError()\n                            }\n                            // 获取替换域名后的完成url: http://a.com/a.js --> http://b.com/a.js\n                            const newSrc = stringReplace(\n                                url, // 原请求完整链接\n                                currentDomain, // 原请求域名\n                                domainMap[currentDomain] // 重载需替换域名\n                            )\n                            // 重要： 调用用户自定义onRetry方法，传递currentUrl, originalUrl, statistics。可以在这里替换请求连接或是更改domain\n                            const userModifiedSrc = onRetry(newSrc, url, currentCollector)\n                            // if onRetry returns null, do not retry this url\n                            if (userModifiedSrc === null) {\n                                return callOriginalOnError()\n                            }\n                            // eslint-disable-next-line\n                            if (typeof userModifiedSrc !== 'string') {\n                                throw new Error('a string should be returned in `onRetry` function')\n                            }\n                            // 是否达到重载的最大次数\n                            if (currentCollector[retryTimesProp] <= maxRetryCount) {\n                                if (realElement instanceof ScriptElementCtor) {\n                                    // 加载script脚本\n                                    loadNextScript(realElement, userModifiedSrc, noop, true)\n                                } else if (realElement instanceof LinkElementCtor) {\n                                    // 加载link标签\n                                    loadNextLink(realElement, userModifiedSrc)\n                                }\n                            } else {\n                                callOriginalOnError()\n                            }\n                        }\n                        return\n                    }\n                    if (key === 'onload') {\n                        self[innerOnloadProp] = newVal\n                        self[innerProxyProp].onload = function(event: Event) {\n                            if (newVal && !newVal._called) {\n                                newVal._called = true\n                                newVal.call(self[innerProxyProp], event)\n                            }\n                        }\n                        return\n                    }\n                    ;(realElement as any)[key] = newVal\n                },\n                get() {\n                    return (self[innerProxyProp] as any)[key]\n                }\n            }\n        }\n        return descriptor\n    }, {} as PropertyDescriptorMap)\n}\n\nconst createHookedElement = function(\n    $element: DynamicElement,\n    opts: InnerAssetsRetryOptions\n): HookedElement {\n    // 给script、link标签打上自定义标签 data-assets-retry-hooked = true\n    $element.setAttribute(hookedIdentifier, 'true')\n    // 定义元素钩子\n    const $hookedElement: HookedElement = {\n        [innerProxyProp]: $element,\n        [innerOnerrorProp]: noop // 空函数\n    }\n    const descriptors = getHookedElementDescriptors($hookedElement, opts)\n    Object.defineProperties($hookedElement, descriptors)\n    $hookedElement.onload = noop\n    $hookedElement.onerror = noop\n    return $hookedElement\n}\n\n/**\n * hook `document.createElement`\n * @param {InnerAssetsRetryOptions} opts\n */\nconst hookCreateElement = function(opts: InnerAssetsRetryOptions) {\n    // 改写document.createElement方法\n    const originalCreateElement = doc.createElement\n    ;(doc as any).createElement = function(name: string, options: any): any {\n        // 针对script、link标签包裹一层\n        if (name === scriptTag || name === linkTag) {\n            // (originalCreateElement as any).call(doc, name) 返回dom对象\n            return createHookedElement((originalCreateElement as any).call(doc, name), opts)\n        }\n        return originalCreateElement.call(doc, name, options)\n    }\n}\n\n/**\n * create a hooked function which hooks every method of target.\n * if a method is hooked and its arguments contains the inner script tag\n * it will be replaced with the value of inner script tag\n *\n * @param {any} target hook target\n */\nconst hookPrototype = function(target: any) {\n    const functionKeys = Object.keys(target).filter(key => isFunctionProperty(target, key))\n    functionKeys.forEach(key => {\n        const originalFunc = target[key]\n        target[key] = function(): any {\n            const args = [].slice.call(arguments).map((item: any) => {\n                if (!item) return item\n                // 针对script、link 进行过滤代理\n                return hasOwn.call(item, innerProxyProp) ? item[innerProxyProp] : item\n            })\n            return originalFunc.apply(this, args)\n        }\n    })\n}\n/**\n * init asynchronous retrying of script tags\n * @param {InnerAssetsRetryOptions} opts\n * @returns\n */\nexport default function initAsync(opts: InnerAssetsRetryOptions) {\n    hookCreateElement(opts)\n    // hookPrototype 为了调用改写后的方法或是属性\n    // eslint-disable-next-line\n    if (typeof Node !== 'undefined') {\n        hookPrototype(Node.prototype)\n    }\n    // eslint-disable-next-line\n    if (typeof Element !== 'undefined') {\n        hookPrototype(Element.prototype)\n    }\n}\n","/** @description data collector */\n\nimport { retryTimesProp, succeededProp, failedProp } from './constants'\n\nexport interface RetryCollector {\n    [x: string]: RetryStatistics\n}\n\nexport interface RetryStatistics {\n    [retryTimesProp]: number\n    [succeededProp]: string[]\n    [failedProp]: string[]\n}\n\n// statistic collector\nexport const retryCollector: RetryCollector = {}\n","import {\n    stringReplace,\n    loadNextScript,\n    loadNextLink,\n    hashTarget,\n    randomString,\n    arrayFrom,\n    getCssRules,\n    getTargetUrl\n} from './util'\nimport { InnerAssetsRetryOptions } from './assets-retry'\nimport { extractInfoFromUrl, splitUrl } from './url'\nimport {\n    retryTimesProp,\n    failedProp,\n    hookedIdentifier,\n    succeededProp,\n    doc,\n    retryIdentifier,\n    onRetryProp,\n    onSuccessProp,\n    onFailProp,\n    domainProp,\n    maxRetryCountProp,\n    ScriptElementCtor,\n    LinkElementCtor,\n    ImageElementCtor,\n    ignoreIdentifier\n} from './constants'\n\nconst retryCache: { [x: string]: boolean } = {}\n\n/**\n * init synchronous retrying of assets,\n * this includes the retrying of\n * script, link and img tags\n *\n * @export\n * @param {InnerAssetsRetryOptions} opts\n */\nexport default function initSync(opts: InnerAssetsRetryOptions) {\n    // opts入参\n    const onRetry = opts[onRetryProp]\n    const onSuccess = opts[onSuccessProp]\n    const onFail = opts[onFailProp]\n    const domainMap = opts[domainProp]\n    /**\n     * capture error on window\n     * when js / css / image failed to load\n     * reload the target with new domain\n     *\n     * @param {ErrorEvent} event\n     * @returns\n     */\n    const errorHandler = function(event: Event) {\n        if (!event) {\n            return\n        }\n        const target = event.target || event.srcElement\n        // 判断是否是HTMLScriptElement、HTMLLinkElement、HTMLImageElement获取对应的链接\n        const originalUrl = getTargetUrl(target)\n        if (!originalUrl) {\n            // not one of script / link / image element\n            return\n        }\n        // 获取当前请求的domain、和收集器（retryTimes次数，failed失败请求url数组、succeeded成功请求url数组）\n        const [currentDomain, currentCollector] = extractInfoFromUrl(originalUrl, domainMap)\n        // 是否存在忽略标识 data-assets-retry-ignore\n        const hasIgnoreIdentifier =\n            target instanceof HTMLElement && target.hasAttribute(ignoreIdentifier)\n        if (!currentCollector || !currentDomain || hasIgnoreIdentifier) {\n            return\n        }\n        // 重载次数自增\n        currentCollector[retryTimesProp]++\n        // 重载失败的url入栈\n        currentCollector[failedProp].push(originalUrl)\n        // 是否达到最大重试次数\n        const isFinalRetry = currentCollector[retryTimesProp] >= opts[maxRetryCountProp]\n        if (isFinalRetry && (target instanceof HTMLElement &&  target.hasAttribute(retryIdentifier))) {\n            // srcPath: /ssi/js/jweixin-1.6.0true.js\n            const [srcPath] = splitUrl(originalUrl, domainMap)\n            onFail(srcPath)\n        }\n\n        // 没有可切换的域名或是达到最大重载次数\n        if (!domainMap[currentDomain] || isFinalRetry) {\n            // can not find a domain to switch\n            // or failed too many times\n            return\n        }\n        // 重载新域名\n        const newDomain = domainMap[currentDomain]\n        // 替换成新域名后的新url\n        const newUrl = stringReplace(originalUrl, currentDomain, newDomain)\n        // 用户在onRetry回调用是否重写新url，如果用户在onRetry不做任何返回，则不在尝试请求\n        const userModifiedUrl = onRetry(newUrl, originalUrl, currentCollector)\n        // if onRetry returns null, do not retry this url\n        if (userModifiedUrl === null) {\n            return\n        }\n        // eslint-disable-next-line\n        if (typeof userModifiedUrl !== 'string') {\n            throw new Error('a string should be returned in `onRetry` function')\n        }\n        // cache retried elements\n        // 如果该标签已经在重载，就不用再重载了，永远只重载一次（dataRetryId唯一性，所以retryCache[elementId]没有再赋值false）\n        const elementId = hashTarget(target)\n        if (retryCache[elementId]) {\n            return\n        }\n        retryCache[elementId] = true\n        if (\n            target instanceof ScriptElementCtor &&\n            !target.getAttribute(hookedIdentifier) &&\n            target.src\n        ) {\n            loadNextScript(target, userModifiedUrl)\n            return\n        }\n        if (\n            target instanceof LinkElementCtor &&\n            !target.getAttribute(hookedIdentifier) &&\n            target.href\n        ) {\n            loadNextLink(target, userModifiedUrl)\n            return\n        }\n        if (target instanceof ImageElementCtor && target.src) {\n            target.setAttribute(retryIdentifier, randomString())\n            target.src = userModifiedUrl\n        }\n    }\n\n    /**\n     * test is link element loaded in load event\n     *\n     * @param {Event} event\n     */\n    const loadHandler = function(event: Event) {\n        if (!event) {\n            return\n        }\n        const target = event.target || event.srcElement\n        const originalUrl = getTargetUrl(target)\n        if (!originalUrl) {\n            // not one of script / link / image element\n            return\n        }\n        if(target instanceof HTMLElement && !target.getAttribute(retryIdentifier)){\n            // 针对于没有触发重载的资源，不做任何处理\n            return;\n        }\n        const [_, currentCollector] = extractInfoFromUrl(originalUrl, domainMap)\n        const [srcPath] = splitUrl(originalUrl, domainMap)\n        const callOnSuccess = () => {\n            if (currentCollector) {\n                currentCollector[succeededProp].push(originalUrl)\n            }\n            onSuccess(srcPath)\n        }\n        // script / img tags succeeded to load without retry, add to collector\n        if (!(target instanceof LinkElementCtor)) {\n            callOnSuccess()\n            return\n        }\n        // 获取所有style样式标签\n        const supportStyleSheets = doc.styleSheets\n        // do not support styleSheets API\n        if (!supportStyleSheets) {\n            return\n        }\n        // 类数组标签节点转化\n        const styleSheets = arrayFrom(doc.styleSheets) as any[]\n        // 过滤出加载完成style样式target，取第一个\n        const targetStyleSheet = styleSheets.filter(styleSheet => {\n            return styleSheet.href === (target as any).href\n        })[0]\n        const rules = getCssRules(targetStyleSheet)\n        if (rules === null) {\n            return\n        }\n        // if the loaded stylesheet does not have rules, treat as failed\n        if (rules.length === 0) {\n            errorHandler(event)\n            return\n        }\n        callOnSuccess()\n    }\n\n    doc.addEventListener('error', errorHandler, true)\n    doc.addEventListener('load', loadHandler, true)\n}\n","import { arrayFrom, stringReplace, toSlug, supportRules, getCssRules } from './util'\nimport { doc, domainProp, onRetryProp, StyleElementCtor } from './constants'\nimport { getCurrentDomain, DomainMap } from './url'\nimport { InnerAssetsRetryOptions } from './assets-retry'\n\ntype UrlProperty = 'backgroundImage' | 'borderImage' | 'listStyleImage'\n// cache for <link rel=\"stylesheet\" />\nconst handledStylesheets: { [x: string]: boolean } = {}\n// cache for <style />\nconst handledStyleTags: HTMLStyleElement[] = []\n\nconst processRules = function(\n    name: UrlProperty,\n    rule: CSSStyleRule,\n    styleSheet: CSSStyleSheet,\n    styleRules: CSSStyleRule[],\n    opts: InnerAssetsRetryOptions\n) {\n    const domainMap = opts[domainProp]\n    const onRetry = opts[onRetryProp]\n    const targetRule = rule.style && rule.style[name]\n    if (!targetRule) {\n        return\n    }\n    // skip data-uri\n    if (/^url\\([\"']?data:/.test(targetRule)) {\n        return\n    }\n    const [_, originalUrl] = targetRule.match(/^url\\([\"']?(.+?)[\"']?\\)/) || []\n    if (!originalUrl) {\n        return\n    }\n    const currentDomain = getCurrentDomain(originalUrl, domainMap)\n    if (!currentDomain || !domainMap[currentDomain]) {\n        return\n    }\n    const urlList = Object.keys(domainMap)\n        .map(domain => {\n            const newUrl = stringReplace(originalUrl, currentDomain, domain)\n            const userModifiedUrl = onRetry(newUrl, originalUrl, null)\n            return `url(\"${userModifiedUrl}\")`\n        })\n        .join(',')\n    const cssText = rule.selectorText + `{ ${toSlug(name)}: ${urlList} !important; }`\n    try {\n        styleSheet.insertRule(cssText, styleRules.length)\n    } catch (_) {\n        styleSheet.insertRule(cssText, 0)\n    }\n}\n\nconst processStyleSheets = (styleSheets: CSSStyleSheet[], opts: InnerAssetsRetryOptions) => {\n    const urlProperties: UrlProperty[] = ['backgroundImage', 'borderImage', 'listStyleImage']\n    styleSheets.forEach((styleSheet: CSSStyleSheet) => {\n        const rules = getCssRules(styleSheet)\n        if (rules === null) {\n            return\n        }\n        const styleRules = arrayFrom(rules) as CSSStyleRule[]\n        styleRules.forEach(rule => {\n            urlProperties.forEach(cssProperty => {\n                processRules(cssProperty, rule, styleSheet, styleRules, opts)\n            })\n        })\n\n        if (styleSheet.href) {\n            handledStylesheets[styleSheet.href] = true\n        }\n        if (styleSheet.ownerNode instanceof StyleElementCtor) {\n            handledStyleTags.push(styleSheet.ownerNode)\n        }\n    })\n}\n\nconst getStyleSheetsToBeHandled = (styleSheets: StyleSheetList, domainMap: DomainMap): CSSStyleSheet[] => {\n    const sheetsArray = arrayFrom(styleSheets) as unknown as CSSStyleSheet[];\n    return sheetsArray.filter(styleSheet => {\n        if (!supportRules(styleSheet)) {\n            return false\n        }\n        // <style /> tags\n        if (!styleSheet.href) {\n            const ownerNode = styleSheet.ownerNode\n            if (ownerNode instanceof StyleElementCtor && handledStyleTags.indexOf(ownerNode) > -1) {\n                return false\n            }\n            return true\n        }\n        if (handledStylesheets[styleSheet.href]) {\n            return false\n        }\n        const currentDomain = getCurrentDomain(styleSheet.href, domainMap)\n        return !!currentDomain\n    })\n}\n\nexport default function initCss(opts: InnerAssetsRetryOptions) {\n    // detect is support styleSheets\n    const supportStyleSheets = doc.styleSheets\n    const domainMap = opts[domainProp]\n    if (!supportStyleSheets) return false\n    setInterval(() => {\n        const newStyleSheets = getStyleSheetsToBeHandled(doc.styleSheets, domainMap)\n        if (newStyleSheets.length > 0) {\n            processStyleSheets(newStyleSheets, opts)\n        }\n    }, 250)\n}\n","import './polyfill'\nimport initAsync from './retry-async'\nimport initSync from './retry-sync'\nimport initCss from './retry-css'\nimport { RetryStatistics, retryCollector } from './collector'\nimport {\n    maxRetryCountProp,\n    onRetryProp,\n    onSuccessProp,\n    onFailProp,\n    domainProp,\n    win\n} from './constants'\nimport { Domain, DomainMap, prepareDomainMaps } from './url'\nimport { identity, noop } from './util'\n\nexport type RetryFunction = (\n    currentUrl: string,\n    originalUrl: string,\n    retryCollector: null | RetryStatistics\n) => string | null\nexport type SuccessFunction = (currentPath: string) => void\nexport type FailFunction = (currentPath: string) => void\n\nexport interface AssetsRetryOptions {\n    [maxRetryCountProp]: number\n    [onRetryProp]?: RetryFunction\n    [onSuccessProp]?: SuccessFunction\n    [onFailProp]?: FailFunction\n    [domainProp]: Domain\n}\n\nexport interface InnerAssetsRetryOptions {\n    [maxRetryCountProp]: number\n    [onRetryProp]: RetryFunction\n    [onSuccessProp]: SuccessFunction\n    [onFailProp]: FailFunction\n    [domainProp]: DomainMap\n}\n\nexport default function init(opts: AssetsRetryOptions = {} as any) {\n    try {\n        // eslint-disable-next-line\n        // 域名列表，只有在域名列表中的资源，才会被重试，未设置domain直接报错\n        if (typeof opts[domainProp] !== 'object') {\n            throw new Error('opts.domain cannot be non-object.')\n        }\n        // 获取配置key值 [maxRetryCount, onRetry, onSuccess, onFail, domain]\n        const optionList = [maxRetryCountProp, onRetryProp, onSuccessProp, onFailProp, domainProp]\n        // 过滤用户配置key(拿到不符合的值)，防止未定义值干扰\n        const invalidOptions = Object.keys(opts).filter(key => optionList.indexOf(key) === -1)\n        // 如果出现校验不通过的key值，直接报错\n        if (invalidOptions.length > 0) {\n            throw new Error('option name: ' + invalidOptions.join(', ') + ' is not valid.')\n        }\n        // 内部默认配置，用户配置覆盖默认配置\n        const innerOpts: InnerAssetsRetryOptions = {\n            [maxRetryCountProp]: opts[maxRetryCountProp] || 3, // 最大重试次数\n            [onRetryProp]: opts[onRetryProp] || identity, // 重载请求之前方法调用，可改写重载的url，一般用于有逻辑判断后修改重url或是重载前的一个拦截\n            [onSuccessProp]: opts[onSuccessProp] || noop, //对于给定资源，要么调用 onSuccess ，要么调用 onFail，标识其最终的加载状态,加载详细信息（成功的 URL、失败的 URL 列表、重试次数）\n            [onFailProp]: opts[onFailProp] || noop, //fail 详情\n            [domainProp]: prepareDomainMaps(opts[domainProp]) // 域名列表，只有在域名列表中的资源，才会被重试\n        }\n        // 初始化异步资源\n        initAsync(innerOpts)\n        initSync(innerOpts)\n        // process.env.__RETRY_IMAGE__ build时构建如果false就会绕过css 重试\n        if (__RETRY_IMAGE__) {\n            initCss(innerOpts)\n        }\n        return retryCollector\n    } catch (e) {\n        win.console && console.error('[assetsRetry] error captured', e)\n    }\n}\n"],"names":["Object","assign","defineProperty","value","target","TypeError","to","index","arguments","length","nextSource","nextKey","prototype","hasOwnProperty","call","writable","configurable","identity","x","noop","collectPropertyNames","obj","getProto","getPrototypeOf","__proto__","keys","concat","filter","key","isFunctionProperty","proto","e","prepareDomainMaps","domains","Array","isArray","some","item","prepareDomainMap","domainsUnion","i","scriptAndLinkProperties","array","map","retryTimesProp","succeededProp","failedProp","maxRetryCountProp","onRetryProp","onSuccessProp","onFailProp","domainProp","innerProxyProp","innerOnerrorProp","scriptTag","linkTag","hookedIdentifier","ignoreIdentifier","retryIdentifier","win","window","doc","document","ElementCtor","HTMLElement","ScriptElementCtor","HTMLScriptElement","StyleElementCtor","HTMLStyleElement","LinkElementCtor","HTMLLinkElement","ImageElementCtor","HTMLImageElement","hasOwn","stringReplace","current","oldStr","newStr","idx","indexOf","substring","arrayFrom","arrayLike","slice","loadNextScript","$script","newSrc","onload","isAsync","newScript","isAsyncScript","defer","async","readyState","test","navigator","userAgent","retryId","randomString","newHtml","outerHTML","replace","write","querySelector","$newScript","createElement","originalNonce","forEach","_","src","onerror","setAttribute","getAttribute","getElementsByTagName","appendChild","getCssRules","styleSheet","rules","cssRules","loadNextLink","$link","newHref","$newLink","href","hashTarget","element","nodeName","join","Math","random","toString","getTargetUrl","retryCollector","reduce","domainMap","domain","getUrlPath","currentDomain","substr","getCurrentDomain","sort","prev","next","extractInfoFromUrl","url","_b","splitUrl","srcPath","_a","getHookedElementDescriptors","self","opts","maxRetryCount","onRetry","descriptor","isFn","apply","set","newVal","realElement","event","stopPropagation","callOriginalOnError","func","thisArg","args","currentCollector","shouldIgnore","hasAttribute","userModifiedSrc","Error","_called","get","hookCreateElement","originalCreateElement","name","options","$element","descriptors","$hookedElement","defineProperties","hookPrototype","originalFunc","this","retryCache","initSync","errorHandler","srcElement","originalUrl","hasIgnoreIdentifier","push","isFinalRetry","onFail","newDomain","newUrl","userModifiedUrl","elementId","onSuccess","addEventListener","callOnSuccess","styleSheets","targetStyleSheet","handledStylesheets","handledStyleTags","processStyleSheets","urlProperties","styleRules","rule","cssProperty","processRules","targetRule","style","match","urlList","cssText","selectorText","$1","$2","toLowerCase","insertRule","ownerNode","getStyleSheetsToBeHandled","supportStyleSheets","optionList_1","invalidOptions","innerOpts","Node","Element","setInterval","newStyleSheets","console","error"],"mappings":"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"}